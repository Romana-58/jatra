pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'production'],
            description: 'Target deployment environment'
        )
        choice(
            name: 'BUILD_MODE',
            choices: ['CHANGED_ONLY', 'ALL_SERVICES'],
            description: 'Build only changed services or all services?'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running tests?'
        )
        booleanParam(
            name: 'DEPLOY_PERFORMANCE_IMPROVEMENTS',
            defaultValue: true,
            description: 'Deploy performance improvements (PgBouncer, HPA, Circuit Breaker)?'
        )
        booleanParam(
            name: 'FORCE_DEPLOY',
            defaultValue: false,
            description: 'Force deployment even if no changes detected?'
        )
    }
    
    environment {
        DOCKER_REGISTRY = 'jatra'
        IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
        NAMESPACE = 'jatra'
        WORKSPACE_DIR = '/workspace'
        KUBECONFIG = '/var/jenkins_home/.kube/config'
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo "üîÑ Checking out code from ${env.GIT_BRANCH}..."
                    sh '''
                        git --version
                        docker --version
                        kubectl version --client
                        echo "Commit: ${GIT_COMMIT}"
                        echo "Branch: ${GIT_BRANCH}"
                    '''
                }
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    echo "üîç Detecting changed services..."
                    sh '''
                        cp -r ${WORKSPACE_DIR}/jenkins /tmp/
                        chmod +x /tmp/jenkins/scripts/*.sh
                        /tmp/jenkins/scripts/detect-changes.sh
                    '''
                    
                    env.CHANGED_SERVICES = readFile('changed-services.txt').trim()
                    
                    if (env.CHANGED_SERVICES == '' && params.BUILD_MODE == 'CHANGED_ONLY' && !params.FORCE_DEPLOY) {
                        echo "‚úÖ No services changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                    
                    echo "üì¶ Services to build: ${env.CHANGED_SERVICES ?: 'ALL'}"
                }
            }
        }
        
        stage('Run Tests') {
            when {
                expression { !params.SKIP_TESTS }
            }
            steps {
                script {
                    echo "üß™ Running tests..."
                    sh '''
                        /tmp/jenkins/scripts/run-tests.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}"
                    '''
                }
            }
        }
        
        stage('Build Docker Images') {
            steps {
                script {
                    echo "üèóÔ∏è  Building Docker images..."
                    sh '''
                        /tmp/jenkins/scripts/build-services.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}" \
                            "${IMAGE_TAG}"
                    '''
                }
            }
        }
        
        stage('Check Cluster Connectivity') {
            steps {
                script {
                    echo "üîó Checking Kubernetes cluster connectivity..."
                    def clusterCheck = sh(
                        script: '''
                            export KUBECONFIG=${KUBECONFIG}
                            kubectl cluster-info && kubectl get nodes
                        ''',
                        returnStatus: true
                    )
                    
                    if (clusterCheck == 0) {
                        echo "‚úÖ Cluster is accessible"
                        env.CLUSTER_AVAILABLE = 'true'
                    } else {
                        echo "‚ö†Ô∏è  Kubernetes cluster not accessible. Skipping deployment stages."
                        env.CLUSTER_AVAILABLE = 'false'
                    }
                }
            }
        }
        
        stage('Load Images to Minikube') {
            when {
                expression { params.ENVIRONMENT == 'dev' && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üì• Loading images to Minikube..."
                    sh '''
                        docker exec -u root jenkins sh -c "
                        export PATH=/usr/local/bin:\$PATH
                        ${WORKSPACE_DIR}/jenkins/scripts/load-to-minikube.sh \
                            '${BUILD_MODE}' \
                            '${CHANGED_SERVICES}'
                        "
                    '''
                }
            }
        }
        
        stage('Deploy Infrastructure') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üèóÔ∏è  Deploying infrastructure components..."
                    sh '''
                        pwd
                        ls -la | head -20
                        export KUBECONFIG=${KUBECONFIG}
                        
                        # Create namespace if not exists
                        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f - || echo "‚ö†Ô∏è  Warning: Could not create namespace"
                        
                        # Deploy ConfigMaps
                        kubectl apply -f infra/kubernetes/configmaps/ || echo "‚ö†Ô∏è  Warning: Could not deploy ConfigMaps"
                        
                        # Deploy Secrets
                        kubectl apply -f infra/kubernetes/secrets/ || echo "‚ö†Ô∏è  Warning: Could not deploy Secrets"
                        
                        # Deploy PostgreSQL (if not exists)
                        kubectl apply -f infra/kubernetes/statefulsets/postgres.yaml || echo "‚ö†Ô∏è  Warning: Could not deploy PostgreSQL"
                        
                        # Deploy Redis
                        kubectl apply -f infra/kubernetes/deployments/redis.yaml || echo "‚ö†Ô∏è  Warning: Could not deploy Redis"
                        
                        # Deploy RabbitMQ (if exists)
                        kubectl apply -f infra/kubernetes/statefulsets/rabbitmq.yaml || echo "‚ö†Ô∏è  Warning: RabbitMQ config not found or could not deploy"
                    '''
                }
            }
        }
        
        stage('Deploy PgBouncer') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üîå Deploying PgBouncer connection pooler..."
                    sh '''
                        pwd
                        ls -la
                        ls -la infra/ || echo "infra not found"
                        export KUBECONFIG=${KUBECONFIG}
                        kubectl apply -f infra/kubernetes/deployments/pgbouncer.yaml || echo "‚ö†Ô∏è  Warning: Could not deploy PgBouncer"
                        
                        # Wait for PgBouncer to be ready
                        kubectl wait --for=condition=ready pod -l app=pgbouncer -n ${NAMESPACE} --timeout=120s || {
                            echo "‚ö†Ô∏è  PgBouncer not ready, checking pods..."
                            kubectl get pods -n ${NAMESPACE} -l app=pgbouncer || echo "‚ö†Ô∏è  Could not get PgBouncer pods"
                            kubectl describe pods -n ${NAMESPACE} -l app=pgbouncer || echo "‚ö†Ô∏è  Could not describe PgBouncer pods"
                        }
                    '''
                }
            }
        }
        
        stage('Deploy HPA') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üìä Deploying Horizontal Pod Autoscalers..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        
                        # Check if metrics-server is installed
                        if ! kubectl get deployment metrics-server -n kube-system &> /dev/null; then
                            echo "üì• Installing metrics-server..."
                            kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml || echo "‚ö†Ô∏è  Warning: Could not install metrics-server"
                            
                            # Patch for minikube
                            kubectl patch deployment metrics-server -n kube-system --type='json' \
                                -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"}]' || echo "‚ö†Ô∏è  Warning: Could not patch metrics-server"
                            
                            sleep 10
                        fi
                        
                        # Deploy HPA manifests
                        kubectl apply -f infra/kubernetes/hpa/ || echo "‚ö†Ô∏è  Warning: Could not deploy HPA"
                    '''
                }
            }
        }
        
        stage('Build API Gateway with Circuit Breaker') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üõ°Ô∏è  Building API Gateway with Circuit Breaker..."
                    sh '''
                        docker build -f apps/api-gateway/Dockerfile -t ${DOCKER_REGISTRY}/api-gateway:${IMAGE_TAG} .
                        docker tag ${DOCKER_REGISTRY}/api-gateway:${IMAGE_TAG} ${DOCKER_REGISTRY}/api-gateway:latest
                        
                        # Load to minikube if dev environment
                        if [ "${ENVIRONMENT}" = "dev" ]; then
                            minikube image load ${DOCKER_REGISTRY}/api-gateway:${IMAGE_TAG}
                            minikube image load ${DOCKER_REGISTRY}/api-gateway:latest
                        fi
                    '''
                }
            }
        }
        
        stage('Deploy Services') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üöÄ Deploying microservices to Kubernetes..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        ${WORKSPACE_DIR}/jenkins/scripts/deploy-k8s.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}" || echo "‚ö†Ô∏è  Warning: Could not deploy services"
                        
                        # Update API Gateway to use circuit breaker image
                        if [ "${DEPLOY_PERFORMANCE_IMPROVEMENTS}" = "true" ]; then
                            kubectl set image deployment/api-gateway \
                                api-gateway=${DOCKER_REGISTRY}/api-gateway:${IMAGE_TAG} \
                                -n ${NAMESPACE} || echo "‚ö†Ô∏è  Warning: Could not update API Gateway image"
                        fi
                    '''
                }
            }
        }
        
        stage('Verify Deployments') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "‚úÖ Verifying deployments..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        
                        echo "üì¶ Checking PgBouncer status..."
                        kubectl get pods -n ${NAMESPACE} -l app=pgbouncer || echo "‚ö†Ô∏è  Could not check PgBouncer pods"
                        
                        echo ""
                        echo "üìä Checking HPA status..."
                        kubectl get hpa -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not check HPA"
                        
                        echo ""
                        echo "üöÄ Checking service deployments..."
                        kubectl get deployments -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not check deployments"
                        
                        echo ""
                        echo "üè• Pod health status..."
                        kubectl get pods -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not check pods"
                    '''
                }
            }
        }
        
        stage('Health Check') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üè• Running health checks..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        ${WORKSPACE_DIR}/jenkins/scripts/health-check.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}" || echo "‚ö†Ô∏è  Warning: Health check failed"
                    '''
                }
            }
        }
        
        stage('Production Approval') {
            when {
                expression { params.ENVIRONMENT == 'production' }
            }
            steps {
                script {
                    def deploymentInfo = """
                    üöÄ PRODUCTION DEPLOYMENT SUMMARY
                    ================================
                    Environment: ${params.ENVIRONMENT}
                    Services: ${env.CHANGED_SERVICES ?: 'ALL'}
                    Image Tag: ${env.IMAGE_TAG}
                    
                    Performance Improvements:
                    - PgBouncer: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    - HPA: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    - Circuit Breaker: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    
                    ‚ö†Ô∏è  This will deploy to PRODUCTION. Proceed?
                    """
                    
                    input message: deploymentInfo, ok: 'Deploy to Production'
                }
            }
        }
        
        stage('Smoke Tests') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üî• Running smoke tests..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        
                        # Test API Gateway health
                        kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -- \
                            curl -f http://api-gateway.${NAMESPACE}.svc.cluster.local:3000/health || {
                            echo "‚ö†Ô∏è  Warning: API Gateway health check failed"
                        }
                        
                        echo "‚úÖ Smoke tests completed (with warnings if any)"
                    '''
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo '‚úÖ Pipeline completed successfully!'
                sh '''
                    export KUBECONFIG=${KUBECONFIG}
                    
                    echo ""
                    echo "üìä DEPLOYMENT SUMMARY"
                    echo "====================="
                    echo "Environment: ${ENVIRONMENT}"
                    echo "Namespace: ${NAMESPACE}"
                    echo "Image Tag: ${IMAGE_TAG}"
                    echo "Cluster Available: ${CLUSTER_AVAILABLE}"
                    echo ""
                    
                    if [ "${DEPLOY_PERFORMANCE_IMPROVEMENTS}" = "true" ] && [ "${CLUSTER_AVAILABLE}" = "true" ]; then
                        echo "üéØ Performance Improvements Deployed:"
                        echo "  ‚úÖ PgBouncer: Connection pooling (1000 ‚Üí 100 connections)"
                        echo "  ‚úÖ HPA: Auto-scaling enabled for all services"
                        echo "  ‚úÖ Circuit Breaker: Fail-fast protection in API Gateway"
                        echo "  ‚úÖ Async Payment: Queue-based processing"
                        echo "  ‚úÖ Atomic Seat Locking: Lua scripts integrated"
                        echo "  ‚úÖ Idempotency: Duplicate prevention active"
                        echo ""
                    fi
                    
                    if [ "${CLUSTER_AVAILABLE}" = "true" ]; then
                        echo "üöÄ Active Services:"
                        kubectl get pods -n ${NAMESPACE} -o wide || echo "‚ö†Ô∏è  Could not get pods"
                        
                        echo ""
                        echo "üìà HPA Status:"
                        kubectl get hpa -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not get HPA"
                        
                        echo ""
                        echo "üîó Access Points:"
                        if [ "${ENVIRONMENT}" = "dev" ]; then
                            echo "  API Gateway: http://$(minikube ip):30000" || echo "‚ö†Ô∏è  Could not get minikube IP"
                        fi
                    fi
                    
                    cat build-summary.txt 2>/dev/null || echo ""
                '''
                
                // Send Slack notification (if configured)
                // slackSend(color: 'good', message: "Deployment to ${params.ENVIRONMENT} successful!")
            }
        }
        failure {
            script {
                echo '‚ùå Pipeline failed!'
                sh '''
                    export KUBECONFIG=${KUBECONFIG}
                    
                    echo ""
                    echo "üîç Debugging Information:"
                    echo "========================"
                    echo "Cluster Available: ${CLUSTER_AVAILABLE}"
                    
                    if [ "${CLUSTER_AVAILABLE}" = "true" ]; then
                        echo ""
                        echo "Pod Status:"
                        kubectl get pods -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not get pods"
                        
                        echo ""
                        echo "Recent Events:"
                        kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' | tail -20 || echo "‚ö†Ô∏è  Could not get events"
                        
                        echo ""
                        echo "Failed Pods Details:"
                        kubectl get pods -n ${NAMESPACE} | grep -v Running | grep -v Completed | tail -n +2 | awk '{print $1}' | xargs -I {} kubectl describe pod {} -n ${NAMESPACE} || echo "‚ö†Ô∏è  Could not describe failed pods"
                    else
                        echo "Cluster not available - no deployment debugging info"
                    fi
                '''
                
                // Send Slack notification (if configured)
                // slackSend(color: 'danger', message: "Deployment to ${params.ENVIRONMENT} failed!")
            }
        }
        always {
            script {
                echo "üßπ Cleaning up workspace..."
                cleanWs()
            }
        }
    }
}
