pipeline {
    agent any
    
    triggers {
        pollSCM('H/5 * * * *')  // Poll GitHub every 5 minutes
    }
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'production'],
            description: 'Target deployment environment'
        )
        choice(
            name: 'BUILD_MODE',
            choices: ['CHANGED_ONLY', 'ALL_SERVICES'],
            description: 'Build only changed services or all services?'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running tests?'
        )
        booleanParam(
            name: 'DEPLOY_PERFORMANCE_IMPROVEMENTS',
            defaultValue: true,
            description: 'Deploy performance improvements (PgBouncer, HPA, Circuit Breaker)?'
        )
        booleanParam(
            name: 'SKIP_CLUSTER_CHECK',
            defaultValue: false,
            description: 'Skip cluster connectivity check (for development/testing)'
        )
    }
    
    environment {
        DOCKER_REGISTRY = 'jatra'
        IMAGE_TAG = "${env.GIT_COMMIT.take(7)}"
        NAMESPACE = 'jatra'
        KUBECONFIG = '/var/jenkins_home/.kube/config'
    }
    
    stages {
        stage('Verify Environment') {
            steps {
                script {
                    echo "üîÑ Checking out code from ${env.GIT_BRANCH}..."
                    sh '''
                        echo "Commit: ${GIT_COMMIT}"
                        echo "Branch: ${GIT_BRANCH}"
                        docker --version
                        kubectl version --client
                    '''
                }
            }
        }
        
        stage('Detect Changes') {
            steps {
                script {
                    echo "üîç Detecting changed services..."
                    sh '''
                        chmod +x ${WORKSPACE}/jenkins/scripts/*.sh
                        ${WORKSPACE}/jenkins/scripts/detect-changes.sh
                    '''
                    
                    env.CHANGED_SERVICES = readFile('changed-services.txt').trim()
                    
                    if (env.CHANGED_SERVICES == '' && params.BUILD_MODE == 'CHANGED_ONLY') {
                        echo "‚úÖ No services changed. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                    
                    echo "üì¶ Services to build: ${env.CHANGED_SERVICES ?: 'ALL'}"
                }
            }
        }
        
        stage('Run Tests') {
            when {
                expression { !params.SKIP_TESTS }
            }
            steps {
                script {
                    echo "üß™ Running tests..."
                    sh '''
                        ${WORKSPACE}/jenkins/scripts/run-tests.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}"
                    '''
                }
            }
        }
        
        stage('Build Docker Images') {
            steps {
                script {
                    echo "üèóÔ∏è  Building Docker images..."
                    sh '''
                        ${WORKSPACE}/jenkins/scripts/build-services.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}" \
                            "${IMAGE_TAG}"
                    '''
                }
            }
        }
        
        stage('Check Cluster Connectivity') {
            when {
                expression { !params.SKIP_CLUSTER_CHECK }
            }
            steps {
                script {
                    echo "üîó Checking Kubernetes cluster connectivity..."
                    def clusterCheck = sh(
                        script: '''
                            export KUBECONFIG=${KUBECONFIG}
                            kubectl cluster-info && kubectl get nodes
                        ''',
                        returnStatus: true
                    )
                    
                    if (clusterCheck == 0) {
                        echo "‚úÖ Cluster is accessible"
                        env.CLUSTER_AVAILABLE = 'true'
                    } else {
                        echo "‚ö†Ô∏è  Kubernetes cluster not accessible. Skipping deployment stages."
                        env.CLUSTER_AVAILABLE = 'false'
                    }
                }
            }
        }
        
        stage('Set Cluster Available for Testing') {
            when {
                expression { params.SKIP_CLUSTER_CHECK }
            }
            steps {
                script {
                    echo "üîß Skipping cluster check for development/testing..."
                    env.CLUSTER_AVAILABLE = 'true'
                }
            }
        }
        
        stage('Load Images to Minikube') {
            when {
                expression { params.ENVIRONMENT == 'dev' && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üì• Loading images to Minikube..."
                    sh '''
                        ${WORKSPACE}/jenkins/scripts/load-to-minikube.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}"
                    '''
                }
            }
        }
        
        stage('Deploy Infrastructure') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üèóÔ∏è  Deploying infrastructure components..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        
                        # Create namespace if not exists
                        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Deploy infrastructure in order
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/configmaps/ || true
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/secrets/ || true
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/statefulsets/postgres.yaml || true
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/deployments/redis.yaml || true
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/statefulsets/rabbitmq.yaml || true
                    '''
                }
            }
        }
        
        stage('Deploy PgBouncer') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üîå Deploying PgBouncer connection pooler..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/deployments/pgbouncer.yaml || true
                        kubectl wait --for=condition=ready pod -l app=pgbouncer -n ${NAMESPACE} --timeout=60s || true
                    '''
                }
            }
        }
        
        stage('Deploy HPA') {
            when {
                expression { params.DEPLOY_PERFORMANCE_IMPROVEMENTS && env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üìä Deploying Horizontal Pod Autoscalers..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        
                        # HPA needs metrics-server (already enabled in minikube addons)
                        kubectl apply -f ${WORKSPACE}/infra/kubernetes/hpa/ || true
                    '''
                }
            }
        }
        

        
        stage('Deploy Services') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üöÄ Deploying microservices to Kubernetes..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        ${WORKSPACE}/jenkins/scripts/deploy-k8s.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}"
                    '''
                }
            }
        }
        
        stage('Verify Deployments') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "‚úÖ Verifying deployments..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        echo "üöÄ Deployments:"
                        kubectl get deployments -n ${NAMESPACE}
                        echo ""
                        echo "üè• Pods:"
                        kubectl get pods -n ${NAMESPACE}
                    '''
                }
            }
        }
        
        stage('Health Check') {
            when {
                expression { env.CLUSTER_AVAILABLE == 'true' }
            }
            steps {
                script {
                    echo "üè• Running health checks..."
                    sh '''
                        export KUBECONFIG=${KUBECONFIG}
                        ${WORKSPACE}/jenkins/scripts/health-check.sh \
                            "${BUILD_MODE}" \
                            "${CHANGED_SERVICES}" || true
                    '''
                }
            }
        }
        
        stage('Production Approval') {
            when {
                expression { params.ENVIRONMENT == 'production' }
            }
            steps {
                script {
                    def deploymentInfo = """
                    üöÄ PRODUCTION DEPLOYMENT SUMMARY
                    ================================
                    Environment: ${params.ENVIRONMENT}
                    Services: ${env.CHANGED_SERVICES ?: 'ALL'}
                    Image Tag: ${env.IMAGE_TAG}
                    
                    Performance Improvements:
                    - PgBouncer: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    - HPA: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    - Circuit Breaker: ${params.DEPLOY_PERFORMANCE_IMPROVEMENTS ? '‚úÖ Enabled' : '‚ùå Disabled'}
                    
                    ‚ö†Ô∏è  This will deploy to PRODUCTION. Proceed?
                    """
                    
                    input message: deploymentInfo, ok: 'Deploy to Production'
                }
            }
        }
        

    }
    
    post {
        success {
            script {
                echo '‚úÖ Pipeline completed successfully!'
                sh '''
                    export KUBECONFIG=${KUBECONFIG}
                    
                    echo "üìä DEPLOYMENT SUMMARY"
                    echo "Environment: ${ENVIRONMENT} | Namespace: ${NAMESPACE} | Image Tag: ${IMAGE_TAG}"
                    
                    if [ "${CLUSTER_AVAILABLE}" = "true" ]; then
                        echo ""
                        echo "üöÄ Services:"
                        kubectl get pods -n ${NAMESPACE}
                        
                        if [ "${ENVIRONMENT}" = "dev" ]; then
                            echo ""
                            echo "üîó Access: http://$(minikube ip):30000" || true
                        fi
                    fi
                '''
            }
        }
        failure {
            script {
                echo '‚ùå Pipeline failed!'
                sh '''
                    export KUBECONFIG=${KUBECONFIG}
                    
                    if [ "${CLUSTER_AVAILABLE}" = "true" ]; then
                        echo "Pod Status:"
                        kubectl get pods -n ${NAMESPACE} || true
                        
                        echo ""
                        echo "Recent Events:"
                        kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' | tail -10 || true
                    fi
                '''
            }
        }
        always {
            script {
                cleanWs()
            }
        }
    }
}
